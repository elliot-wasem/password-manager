/* extern imports */
use crypto::{sha2::Sha256, digest::Digest};
use rand::Rng;

/**
 * Given any input, creates the corresponding Sha256 hash.
 */
pub fn hash256(input: &str) -> String {
    let mut hasher = Sha256::new();
    hasher.input_str(input);
    hasher.result_str()
}

/**
 * Given a plaintext key and some input, generates a Sha256 key of greater or
 * equal length to the input, where the full key is generated by chaining all
 * previously generated Sha256 hashes together, and feeding it into the Sha256
 * hasher again.
 */
pub fn get_sha_key(input: &str, key: &str) -> String {
    let mut sha_key: String = hash256(key);
    while sha_key.len() < input.len() {
        sha_key = format!("{}{}", sha_key, hash256(&sha_key));
    }
    sha_key
}

/**
 * Given some target length, generates a Vec<u8> of that length where each u8
 * is a random byte.
 */
pub fn get_obfusc_buf_u8(len: i64) -> Vec<u8>{
    let mut buf: Vec<u8> = Vec::new();
    let mut rand = rand::thread_rng();
    for _ in 0..len {
        buf.push(rand.gen());
    }
    buf
}

/**
 * takes the plaintext key and, if the plaintext key matches the original key 
 * provided to encrypt the file, extracts the password file originally 
 * encrypted. If the plaintext password was wrong, the program will crash.
 */
pub fn retrieve_saved_gen(key: &str, buf: Vec<u8>) -> Vec<u8> {
    let mut result: Vec<u8> = Vec::new();
    let mut sha_key = hash256(key);
    let mut count_q = 0;
    let mut i = 0;
    loop {
        let index: usize = sha_key[0..=i].as_bytes().iter().fold(0,|a, &b| a + b as usize);
        let temp_val = buf[index]^sha_key.as_bytes()[i];
        if temp_val == 'Q' as u8 {
            count_q += 1;
            if count_q == 3 {
                break;
            }
        }
        result.push(temp_val);
        if i == sha_key.len() - 1 {
            sha_key = format!("{}{}", sha_key, hash256(&sha_key));
        }
        i += 1;
    }
    result.pop();
    result.pop();
    result
}

/**
 * Encrypts the plaintext input file by xor-ing it against a same-length
 * sequence of Sha256-generated bytes, and returning that to the caller.
 */
pub fn encrypt_string_gen(input: &str, key: &str) -> Vec<u8> {
    let mut sha_key: String = hash256(key);
    let padded_input: String = format!("{}{}", input, "QQQ");
    let mut output: Vec<u8> = Vec::new();
    let input_bytes = padded_input.as_bytes();
    while sha_key.len() < input_bytes.len() {
        sha_key = format!("{}{}", sha_key, hash256(&sha_key));
    }
    let sha_key_bytes = sha_key.as_bytes();
    for i in 0..padded_input.len() {
        output.push(input_bytes[i]^sha_key_bytes[i]);
    }
    output
}
